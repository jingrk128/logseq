- 沈建華 ARM系統開發者指南
- 4.3.1和4.3.2影片沒有提到
- ### ARM處理區域變數和函式參數的方式
	- 在ARM中宣告變數或函式入口參數時，如果數量不多，ARM都會單獨分配32bit暫存器來儲存它們
		- 即使變數宣告成8/16bit也是用32bit儲存
	- 所以用8/16bit不但省不了空間，還會對效能造成影響，來看以下例子
		- 例1，參數用32bit
			- ```
			  int wordinc (int a)
			  {
			  	return a+1;
			  }
			  ```
			- 編譯器轉換成組合語言後如下：
			- ```
			  wordinc
			  ADD a1,a1,#1
			  MOV PC,LR
			  ```
				- 這個例子效率最高，沒有任何問題
		- 例2，參數用char，char在ARM是unsinged的8bit
			- ```
			  int charinc(char a)
			  {
			  	return a+1;
			  }
			  ```
			- 編譯器轉換成組合語言後如下：
			- ```
			  wordinc
			  ADD a1,a1,#1
			  AND a1,a1,#&ff
			  MOV PC,LR
			  ```
				- 比起例1，多了`AND a1,a1,#&ff`這一行，故效率較差
					- 多那一行是因為a是char，故編譯器會做把多餘的24bit都清0這件事
		- 例3，參數用short，帶正負號的16bit
			- ```
			  Int shortinc(short a)
			  {
			  	return a+1;
			  }
			  ```
			- 編譯器轉換成組合語言後如下：
			- ```
			  wordinc
			  ADD a1,a1,#1
			  MOV a1,a1,LSL #16
			  MOV a1,a1,ASR #16
			  MOV PC,LR
			  ```
				- 比起例1，多了兩條指令，效率就更差了
					- 多的兩條是做邏輯左移16ibt，再做算術右移16bit回來
						- 這是為了確保32bit暫存器的高16bit都能正確反映正負號
	- 所以若沒有嚴重空間不足的問題，一般將變數宣告成32bit是效率最高的做法
- ### 迴圈
	- i++和i--的差異
		- i++
			- ```
			  int factl(int limit)
			  {
			  	for(i=1; i<=limit; i++)
			  		fact = fact*i;
			  }
			  ```
			- 編譯器轉成組合語言如下，用了四條指令
			- ```
			  Factl
			  						;R0是limit，R1是i，R2是fact
			  0x000010:MUL R2,R1,R2	;R1和R2相乘後結果放到R2
			  0x000014:ADD R1,R1,#1	;R1+1
			  0x000018:CMP R1,R0		;把i拿去和limit比較
			  0x00001c:BLE 0x10		;BLE是Less or equal，如果是小於等於，就jump回0x10的位址
			  ```
		- i--
			- ```
			  int fact2(int limit)
			  {
			  	for(i=limit; i!=0; i--)
			  		fact = fact*i;
			  }
			  ```
			- 編譯器轉成組合語言如下，只用三條指令
			- ```
			  Fact2
			  0x000010:MUL	R2,R1,R2
			  0x000014:SUBS	R1,R1,#1
			  0x00001c:BNE	0x10		;如果R1不等於0，就jump回0x10
			  ```
		- 可以看出來，i--比i++少執行一條指令，迴圈次數越多，兩種寫法的效能就越明顯