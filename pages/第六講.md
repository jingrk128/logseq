### 關鍵字
	- struct(課堂沒教)
		- ```
		  struct bs
		  {
		  	unsigned a:4;
		      unsigned :0;
		      unsigned b;
		  }
		  ```
		- a之後填0，表示剩下的bit都不使用，所以b和a在不同的變數上面
	- sizeof
		- `sizeof(i)`和`sizeof i`都是合法的，但後者已經沒人用了，忘了它吧
		- ```
		  char ss[] = "0123456789";
		  sizeof(ss)
		  ```
			- 答案是11，因為sizeof會計算到`\0`
- ### 運算子(運算符)
	- 逗號
		- `if(a+3, b/2, c>=0)`
			- 這是合法的語法
			- 用逗號隔開的三個運算式都會執行，且最後if會取的值是最後一個運算式(c>=0)
			- 前兩個運算式也會執行，但因為沒有賦值，所以有做和沒做都沒差
		- `for(int p=q)`
	- 優先順序
		- |順序|運算子|
		  |1|()、[]、->、.|
		  |2|!、~、++、--、-、*、&、sizeof|
		  |3|*、/、%|
		  |4|+、-|
		  |5|<<、>>|
		  |6|<、<=、>、>=|
		  |7|==、!=|
		  |8|&|
		  |9|^|
		  |10|｜|
		  |11|&&|
		  |12|｜｜|
		  |13|?:|
		  |14|=|
		  |15|,|
		  |1|_|_|
		- 不用全記，記前五個和後三個就差不多了
		- 以下語法，不同的compiler會有不同的結果
			- ```
			  int c;
			  c = c+ --c
			  ```
- ### 運算式求值 - 隱含的類型轉換
	- ```
	  void foo()
	  {
	  	unsigned int a = 6;
	      int b = -20;
	      (a+b>6)?printf(">6\n"):printf("<=6\n");
	  }
	  ```
		- 注意，以上片段會印出">6"
		- 因為a和b的類型不同，放在一起做運算時，compiler會將兩個變數調整成相同的類型再做運算
		- 優先順序為：
			- double > float > unsigned long > long > unsigned int > int
	- ```
	  int a = 5000;
	  int b = 50;
	  long c = a * b;
	  ```
		- 在16bit的環境，這個程式碼會有溢位問題，因為a*b大於65535
		- 解決方法可以利用隱含類型轉換，如下
		- ```
		  long c = (long)a * b;
		  ```
		- 因為a已經轉成long，所以b也會被隱涵轉換成long
			-