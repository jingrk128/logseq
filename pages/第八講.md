### 字串 - 字元陣列
	- ```
	  char *p, *q;
	  p = "Hello!";
	  p = q;
	  q[0] = 'h';
	  ```
		- 第四行是錯誤的操作，因為對String Literal Pool進行修改的行為是被禁止的
	- 字串會被compiler分配到String Literal Pool
		- 在ANSI C中禁止修改String Literal Pool的內容
		- 嵌入式系統通常會把String Literal Pool映射到read only的記憶體空間
			- 在ARM要修改String Literal Pool的話，會引發Data Abort的錯誤
	- `printf("Hello world\n");`
		- `"Hello world\n"`這個字串在這一行執行完之後，雖然它會一直佔用記憶體，但再也沒人找得到它了
			- 因為沒有使用symbol記住它的address
- ### function
	- function prototype(函數原型)
		- 呼叫之前宣告函數原型，可以讓compiler確定這個function引用的參數數量和類型，還有回傳值類型
		- 後續若有該function有被呼叫，compiler就會檢查呼叫者上述的資訊是否正確
		- 有兩種寫法(以下兩個是等價的)
			- 1.寫出參數的變數名稱 - `int myfunc(int a, int array[])`
			- 2.不寫參數的變數名稱 - `int myfunc(int, int *);`
				- 因為compiler不會檢查參數的變數名稱，所以不寫也可以
		- 函數宣告和函數定義寫法上最大不同在
			- 函數宣告的結尾是分號
			- 函數定義的結尾是大括號
	- 可執行的程式碼只能放在function裡面
		- 在function外面只能存在宣告和定義，這兩個不算是可執行程式碼
		- 宣告(declaration)
			- 該行程式碼只是跟compiler說明一件事情，不需要為該程式碼行劃分出記憶體空間
			- ```
			  extern int i;
			  ```
				- 這是宣告，它只說明i是在另一個.c檔定義的，並沒有為i保留記憶體空間
			- ```
			  int func(int, char);
			  ```
				- 這是function prototype，function prototype是宣告，它只有指定參數的數量、類型，但沒有指定實作的程式碼，無法確定(故也不需要)為這個function保留憶體空間
		- 定義(definition)
		  id:: 65448c2d-7db6-4bea-8681-2cb998805ce0
			- 如果要為宣告的東西保留記憶體空間，則稱為定義
			- ```
			  int i;
			  ```
				- 這是宣告，同時也是定義，因為i佔據的記憶體空間已經被確定了
				- 網路上有些文章會把這寫法當作宣告，可參考：
					- [C 語言的宣告、定義、儲存類型 (storage class) 與連結性 (linkage) - DEV Community](https://dev.to/codemee/c-yu-yan-de-xuan-gao-ding-yi-chu-cun-lei-xing-storage-class-yu-lian-jie-xing-linkage-4p1d)
			- ```
			  int myfunc()
			  {
			  	printf("hello world\n");
			  }
			  ```
				- 這是宣告，同時也是定義，因為這段程式碼的內容已經確定了這個function會佔用多少空間
	- 在一般的compiler，main()是程式開始的入口
		- 在windows的入口不是main()，而是WinMain()
		- 在嵌入式系統的入口也不是main()，而是從系統中斷向量表指定的指令開始，後續才會jump到main()
			- 一部份是人寫的
			- 另一部份是linker產生的
	- function的參數傳遞
		- caller：呼叫者
		- callee：被呼叫者
		- 傳遞方式
			- 傳值不傳址
				- 指標也一樣，因為指標的值就是位址
			- 透過register和stack傳遞
				- ARM會先用R0 R1 R2 R3暫存器來傳遞，暫存器不夠用的話再用stack，因為暫存器效率較高
				- stack傳遞的規則
					- 最後一個先傳，第一個最後傳