- 10:00 #到RKIT
- ### read_retry的流程(child cmd)
  id:: 646ec786-bd0c-4c42-929d-ee510f7bdf56
	- #2311 #trunk #svn25943 #DL_Flashdisk_ASIC_YMTC_X1_9050_CLIENT
	- 以下假設每次retry的結果都是decode fail，所以會retry到次數上限
	- read -> ldma_done -> [[NfcSchedHandleLdmaDone()]]
		- read decode fail
		- opCmd->state = NFC_SCHED_RECVD_ERR
	- [[NfcSched_SchedCmd()]]@1 -> [[NfcSchedHandleError()]] -> [[NfcExcp_SchedUncProc()]]
	- hard retry：
		- ->[[NfcExcpHandleHardDecodeError()]]
		- 建立child cmd
		- 推入到WaitQueue
		- child->state = NFC_SCHED_WAIT_SCHED
	- -> [[NfcSched_SchedCmd()]]@2 ->[[NfcSchedTrySendCMD()]]
	- [[NfcSchedTrySendCMD()]]做完後 -> 返回到[[NfcSched_SchedCmd()]]
		- 推入WaitRspQueue
		- ldma_done -> [[NfcSchedHandleLdmaDone()]]
			- child->state = NFC_SCHED_DONE
			- 推入gNfcRspQ
		- -> [[NfcSched_SchedChildCmd()]]
			- 從gNfcRspQ撈出child cmd -> [[NfcSched_SchedCmd()]]@4
			- ->[[NfcExcp_HandleChildDone()]]
				- 釋放child cmd
				- [[NfcExcp_SchedUncProc()]]
					- hard retry次數已達上限?
						- 否 - 跳回到hard retry的開頭
						- 是 - 開始soft retry
		- soft retry：
			- -> [[NfcExcpHandleSoftDecodeError()]]
				- 建立child cmd
				- 推入到WaitQueue
				- child->state = NFC_SCHED_WAIT_SCHED
			- -> [[NfcSched_SchedCmd()]]@3
		- soft retry - NfcSchedTrySendCMD()
			- -> [[NfcSchedTrySendCMD()]] -> [[NfcSched_HandleSoftDecodeRead()]]
			- ldpcRetrySeq++
			- ldpcRetrySeq等於LDPC_RETRY_READ_COUNT嗎？
				- 是 - 回傳RET_OK
					- [[NfcSchedTrySendCMD()]]做完後 -> 返回到[[NfcSched_SchedCmd()]]
						- 推進WaitRspQueue
				- 否 - 回傳RET_BUSY
					- [[NfcSchedTrySendCMD()]]做完後 -> 返回到[[NfcSched_SchedCmd()]]
						- 沒有推入WaitRspQueue，停留在WaitQueue
			- 如果soft retry只做完第1 part
				- 此時[[NfcSched_SchedChildCmd()]]還沒撈WaitQueue
					- 所以直接從[[NfcSched_SchedChildCmd()]]的下半部迴圈接著做
					- 從WaitQueue撈出child cmd
					- -> [[NfcSched_SchedCmd()]]@5
					- 跳回到"soft retry - NfcSchedTrySendCMD()"
			- 如果soft retry只做完第2 part
				- 不會產生ldma_done，所以也不會進[[NfcSchedHandleLdmaDone()]]
				- -> [[NfcSched_SchedChildCmd()]]
					- 從WaitQueue撈出child cmd
					- -> [[NfcSched_SchedCmd()]]@5
					- 跳回到"soft retry - NfcSchedTrySendCMD()"
			- 如果soft retry做完第3 part了
				- ldma_done -> [[NfcSchedHandleLdmaDone()]]
					- child->state = NFC_SCHED_DONE
					- 推入到gNfcRspQ
				- -> [[NfcSched_SchedChildCmd()]]
					- 從gNfcRspQ撈出child cmd -> [[NfcSched_SchedCmd()]]@4
					- ->[[[[NfcExcp_HandleChildDone()]]
						- 釋放child cmd
						- [[NfcExcp_SchedUncProc()]]
							- hard retry次數已達上限?
								- 否 - 跳回到soft retry的開頭
								- 是 - 結束read retry流程
-
- ### diffZeroOne是什麼？
  id:: 646f8c70-a116-4a8c-bedd-dd40e21b2f85
	- #2311 #LDPC
	- diffZeroOne是簡寫，全名是Difference of zero’s and one’s count
	- 表示一個cw裡面1和0的數量差異
		- 單位不是1個bit，可能是16 or 32bit
	- diffZeroOne會影響到scramble
		- 需要scramble的原因是：
			- 若原始資料裡同樣的資料都擺放在一起，也就是一整塊都是1，或一整塊都是0
				- 會產生大量電位同性相斥的狀況，造成cell之間的電壓彼此干擾，而導致容易讀錯資料
			- 透過scramble，可以將資料的1和0重新排列
				- 不論是縱向還是橫向，儘量讓1和0穿插排列，避免多數的1和0擺放在一起
				- 這樣就能減少cell之間彼此干擾的問題
	- 所以當decode fail的時候，我們會需要diffZeroOne來判斷是否此值過大
	- 當使用hard retry時，會依據diffZeroOne調整bestRrtIndex[]和best01Diff[]
		- 看起來調整這兩個array是為了調整soft retry的
	- 2311可以在LDPC_DEC_ERR_STATUS_DATA這個暫存器讀取到diff_zero_one
		- 在0x5470_00E0的bit[23:16]