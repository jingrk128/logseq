- 09:53 #到RKIT
- 發現outlook的msedgewebview2.exe一直在吃14%左右的cpu負載
	- [修复 Windows 11/10 上的 Msedgewebview2.exe 高 CPU 和内存使用率 | Digitalixy.com](https://digitalixy.com/windows/835978.html)
	  雖然這個網頁提到建議關掉teams可解決問題，但我關了，cpu還是沒掉下來
	- [什麼是 Microsoft Edge WebView2 運行時（以及如何降低 CPU 使用率）？ - 0x資訊 (0xzx.com)](https://0xzx.com/zh-tw/2023020911293156589.html)
	  這邊說從工作管理員關掉msedgewebview2.exe，下次重開機時問應該就會被修復了
- #2311 #檢查有無sw_queue #拆解Nfc_ResetFlashCmd()
	- 在NfcSched_HandleDone()裡會檢查gNfcBlockCbFlag來決定要不要執行callback
		- gNfcBlockCbFlag為0就會執行callback
		- gNfcBlockCbFlag只有在NFCInf_Wait_All_Req_Done_WoCb()會被設1
		- 而目前沒有人會呼叫NFCInf_Wait_All_Req_Done_WoCb()
		- 所以跑到這邊時一定會執行callback
	- 關於opCmd在各個queue之間的流動
		- 在init時，會執行NfcCom_Init()，把所有的opCmd串起來，並讓gNfcOpCmdMgr.head指到第一個opCmd，gNfcOpCmdMgr.tail指到最後一個opCmd->next
		- NFCInf_Req_Submit()和NFCInf_Sync_Req()在執行完cmd後，都會把opCmd放入gNfcWaitRspQ
		- 在NfcSchedHandleCmdNfcStatus()，會把opCmd放入gNfcRspQ
		- 在NfcSched_HandleDone()會執行NfcCom_FreeOpCmd()，把opCmd放到gNfcOpCmdMgr的最後一個
		- gNfcRepairQA和gNfcChCmdMgr.gNfcWaitQ目前感覺只有在發生unc的時候才會用到
- #無法print
	- 看到開卡時，看到uart有印0: read status fail: die:2 fail, ret b.，而我搜尋code，只有Nfc_ReadStatus()有印這一段，所以我想它是有執行Nfc_ReadStatus()的
		- ```
		  
		  uint32_t Nfc_ReadStatus(uint8_t die)
		  {
		      uint32_t    result;
		      NFC_CMD_T *cmd = NFC_Cmd_Aquire();
		  
		      cmd->ops.raw = 0;
		      cmd->request.nonDataReq.die = die;
		      cmd->request.nonDataReq.opId = OP_ID_READ_STATUS;
		      cmd->opType = OP_TYPE_NONE_DATA;
		      NFCInf_Wait_All_Req_Done();
		      result = NFCInf_Sync_Req(cmd);
		  
		      if (NF_RET_OP_OK != result)
		      {
		          NFC_PRINTF(LOG_LVL_WARN, "read status fail: die:%d fail, ret %x.\r\n", die, result);
		          NFC_PRINTF(LOG_LVL_WARN, "111\r\n");
		      }
		      return result;
		  }
		  ```
	- 彷照它的方法，想印出111，但是實際上，我再開卡一次，它卻沒有印出111
	- johnny建議把\\r拿掉，但還是沒有印出
- #2311 #jtag
	- 接頭上白色邊是第一腳
- #2311 [[IAR load code]]
	- 左下選擇Core0
	- 左上選擇DL_Flashdisk_ASIC_YMTC_X1_9050_CLIENT
	- 第一次load code會出現以下訊息
	  ```
	  You are using a J-Link which does not have Intelligence for the selected CPU core[Cortex-R5]in the firmware.
	  In t lli gence in the firmware enables J-Link to generate sequences for the CPU core.
	  Wi hou this feature all sequences are generated by the PC.
	  Intelligence in the firmware are allows higher target interface speeds and significantly enhances both speed and stability of the communication with the target CPU.
	  You can use this J Link with your target CPU,but we recommend using a newer model of J-Link/J-Trace.
	  ```
	  勾選"Don not show this message again for today"即可
- #2311 [[IAR load code]] #fail
	- 出現以下訊息
	  The stack plug-in failed to set a break point on"main'.The Stack window will not be able to display stack contents.
	  (You can change thi setting in the Tools>Options dialog box)
	  且按OK之後，程式沒有停在main()
		- 重開IAR和Rebuild All都沒有改善
		- Tools->options->stack->取消勾選“stack pointer(s) not valid until program reaches”，也沒有改善
		- options->linker->output->勾選"Include debug information in output"
		  這樣load code就會停在gk2311_startup.s，也能正常跑起來了
- #2311 #摸索FW
	- 在\inc\Feature.h 把MP_BOOT_FROM_LOADER關掉，init時才會對每個ce做掃描
	- NFC_PRINTF()似乎無法打印出來，需要再研究
	-